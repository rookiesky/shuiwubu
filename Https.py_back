import requests
import logging
import json
import random
import os
import telnetlib
from datetime import datetime, timedelta

class Https():
    porxy_ips = []
    is_porxy = False

    def __init__(self,is_porxy = False):
        logging.basicConfig(format='%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s',
                    level=logging.INFO)
        self.is_porxy = is_porxy
        if self.is_porxy == True:
            self.porxies()

    def userAgent(self):
        ua = [
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.8; rv:21.0) Gecko/20100101 Firefox/21.0',
            'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:21.0) Gecko/20130331 Firefox/21.0',
            'Mozilla/5.0 (Windows NT 6.2; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/535.11 (KHTML, like Gecko) Ubuntu/11.10 Chromium/87.0.4280.88 Chrome/87.0.4280.88 Safari/537.36',
            'Mozilla/5.0 (Windows NT 6.2; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.94 Safari/537.36',
            'Mozilla/5.0 (compatible; WOW64; MSIE 10.0; Windows NT 6.2)',
            'Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.9.168 Version/11.52',
            'Opera/9.80 (Windows NT 6.1; WOW64; U; en) Presto/2.10.229 Version/11.62'
        ]
        return random.choice(ua)
    
    def httpHeader(self,header):
        porxies = {}
        if self.is_porxy:
            if len(self.porxy_ips) <= 0:
                self.getPorxy()
            porxies = self.porxy_ips[0]
            del self.porxy_ips[0]
        
        head = {'user-agent': self.userAgent()}
        header = {**head,**header}
        return {'porxies':porxies,'header':header}
        

    def get(self,url,header={}):
        '''http get请求
        Parameters
        -------------------
        url : string 请求链接
        header : dict 请求header

        Returns
        -------------------
        string
        '''
        header = self.httpHeader(header=header)
        try:
            response = requests.get(url=url, headers = header['header'], proxies = header['porxies'], timeout = 120)
            return response.text
        except Exception as e:
            logging.error('http get error,msg:{}'.format(e))
        finally:
            try:
                response.close()
            except:
                pass

    def post(self,url,data,header = {}):
        '''http post请求
        Parameters
        ----------------
        url : string 请求接口
        data : dict  请求数据
        header : http header

        RETURNS
        ---------------
        string response
        '''
        header = self.httpHeader(header=header)
        try:
            response = requests.post(url=url,data=data, headers = header['header'], proxies = header['porxies'], timeout = 120)
            return response.text
        except Exception as e:
            logging.error('http post error,msg:{}'.format(e))
        finally:
            try:
                response.close()
            except:
                pass

    def postJson(self,url,json):
        '''http post json请求
        Parameters
        ----------------
        url : string 请求接口
        json : dict  请求数据

        RETURNS
        ---------------
        string response
        '''
        try:
            response = requests.post(url=url,json=json)
            return response.text
        except Exception as e:
            logging.error('post json error,msg:{}'.format(e))
        finally:
            try:
                response.close()
            except:
                pass  

    def getPorxyApi(self):
        '''请求代理ip接口或者代理ip
        RETURN:
            data = []
        '''
        try:
            response = requests.get('https://raw.githubusercontent.com/fate0/proxylist/master/proxy.list')
            return response.text.split("\n")
        except Exception as e:
            logging.error('get porxy api error,msg:{}'.format(e))
            return False
    
    def checkPorxyIp(self,ip):
        '''检测代理ip是否可用
        RETURN:
            True 可用
            Flase 不可用
        '''
        try:
            response = requests.get('https://www.baidu.com', proxies=ip, timeout=5)
            if response.status_code > 302:
                return False
            return True
        except:
            return False
        finally:
            try:
                response.close()
            except:
                pass

    def checkIp(self,ip,port):
        try:
            telnetlib.Telnet(ip,port=port,timeout=3)
            return True
        except:
            return False

    def getPorxy(self):
        '''获取代理ip
        '''
        ips = self.getPorxyApi()
        if ips == False:
            exit()
        
        for ip in ips:
            if ip == '':
                continue
            ip = json.loads(ip)
            porxy_host = {ip['type']:ip['type'] + '://' + ip['host'] + ':' + str(ip['port'])}
            check = self.checkPorxyIp(porxy_host)
            # check = self.checkIp(ip['host'],ip['port'])
            if check == False:
                continue
            self.porxy_ips.append(porxy_host)
            print(len(self.porxy_ips))
        
        if len(self.porxy_ips) <= 0:
            logging.error('get ips list empty')
            exit()
        data = "\n".join(str(item) for item in self.porxy_ips)
        self.setPorxyFile(data)

    def setPorxyFile(self,data):
        with open('porxy_ip.txt','w') as f:
            f.write(data)
        with open('timeout.log','w') as f:
            f.write(datetime.strftime(datetime.now(),'%Y-%m-%d %H:%M:%S'))
        data = ''

    def getPorxyFile(self):
        with open('porxy_ip.txt','r') as f:
            data = f.read()
        
        self.porxy_ips = data.split('\n')
        

    def porxies(self):
        logging.info('get porxy ip...')
        if os.path.exists('timeout.log'):
            with open('timeout.log','r') as f:
                date = f.read()
        
            now_time = datetime.now()
            last_new = datetime.strptime(date,'%Y-%m-%d %H:%M:%S')
            d = now_time - last_new > timedelta(minutes=15)
            if d == True:
                self.getPorxy()
            self.getPorxyFile()
        else:
            self.getPorxy()
        logging.info('get porxy ip success')